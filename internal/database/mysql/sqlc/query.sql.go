// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: query.sql

package sqlc

import (
	"context"
	"time"
)

const acceptBid = `-- name: AcceptBid :exec
UPDATE Bids SET Status = "accepted" WHERE BidId = ?
`

func (q *Queries) AcceptBid(ctx context.Context, bidid string) error {
	_, err := q.db.ExecContext(ctx, acceptBid, bidid)
	return err
}

const createAccount = `-- name: CreateAccount :exec
INSERT INTO Users (UserID, Name, Email, Password,Type)
VALUES (?,?,?,?,?)
`

type CreateAccountParams struct {
	Userid   string
	Name     string
	Email    string
	Password string
	Type     string
}

func (q *Queries) CreateAccount(ctx context.Context, arg CreateAccountParams) error {
	_, err := q.db.ExecContext(ctx, createAccount,
		arg.Userid,
		arg.Name,
		arg.Email,
		arg.Password,
		arg.Type,
	)
	return err
}

const createBid = `-- name: CreateBid :exec
INSERT INTO Bids (BidId, CommodityId, UserID, Price,Duration)
VALUES (?,?,?,?,?)
`

type CreateBidParams struct {
	Bidid       string
	Commodityid string
	Userid      string
	Price       string
	Duration    int32
}

func (q *Queries) CreateBid(ctx context.Context, arg CreateBidParams) error {
	_, err := q.db.ExecContext(ctx, createBid,
		arg.Bidid,
		arg.Commodityid,
		arg.Userid,
		arg.Price,
		arg.Duration,
	)
	return err
}

const createCommodity = `-- name: CreateCommodity :exec
INSERT INTO Commodities (CommodityId, UserID, Name, Description, Price, Category)
VALUES (?,?,?,?,?,?)
`

type CreateCommodityParams struct {
	Commodityid string
	Userid      string
	Name        string
	Description string
	Price       string
	Category    string
}

func (q *Queries) CreateCommodity(ctx context.Context, arg CreateCommodityParams) error {
	_, err := q.db.ExecContext(ctx, createCommodity,
		arg.Commodityid,
		arg.Userid,
		arg.Name,
		arg.Description,
		arg.Price,
		arg.Category,
	)
	return err
}

const createVerification = `-- name: CreateVerification :exec
INSERT INTO Verifications (VerificationId, UserID, OTP, ExpiresAt)
VALUES (?,?,?,?)
`

type CreateVerificationParams struct {
	Verificationid string
	Userid         string
	Otp            int32
	Expiresat      time.Time
}

func (q *Queries) CreateVerification(ctx context.Context, arg CreateVerificationParams) error {
	_, err := q.db.ExecContext(ctx, createVerification,
		arg.Verificationid,
		arg.Userid,
		arg.Otp,
		arg.Expiresat,
	)
	return err
}

const deleteVerification = `-- name: DeleteVerification :exec
DELETE FROM Verifications WHERE UserID = ?
`

func (q *Queries) DeleteVerification(ctx context.Context, userid string) error {
	_, err := q.db.ExecContext(ctx, deleteVerification, userid)
	return err
}

const getBidsForCommodity = `-- name: GetBidsForCommodity :many
SELECT BidId, CommodityId, UserID, Price, Status, Duration FROM Bids WHERE CommodityId = ?
`

type GetBidsForCommodityRow struct {
	Bidid       string
	Commodityid string
	Userid      string
	Price       string
	Status      string
	Duration    int32
}

func (q *Queries) GetBidsForCommodity(ctx context.Context, commodityid string) ([]GetBidsForCommodityRow, error) {
	rows, err := q.db.QueryContext(ctx, getBidsForCommodity, commodityid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetBidsForCommodityRow
	for rows.Next() {
		var i GetBidsForCommodityRow
		if err := rows.Scan(
			&i.Bidid,
			&i.Commodityid,
			&i.Userid,
			&i.Price,
			&i.Status,
			&i.Duration,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCommodities = `-- name: GetCommodities :many
SELECT CommodityId, UserID, Name, Description, Price, Status, Category, CreatedAt, UpdatedAt FROM Commodities
`

type GetCommoditiesRow struct {
	Commodityid string
	Userid      string
	Name        string
	Description string
	Price       string
	Status      string
	Category    string
	Createdat   time.Time
	Updatedat   time.Time
}

func (q *Queries) GetCommodities(ctx context.Context) ([]GetCommoditiesRow, error) {
	rows, err := q.db.QueryContext(ctx, getCommodities)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCommoditiesRow
	for rows.Next() {
		var i GetCommoditiesRow
		if err := rows.Scan(
			&i.Commodityid,
			&i.Userid,
			&i.Name,
			&i.Description,
			&i.Price,
			&i.Status,
			&i.Category,
			&i.Createdat,
			&i.Updatedat,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCommoditiesByBidId = `-- name: GetCommoditiesByBidId :one
SELECT CommodityId FROM Bids WHERE BidId = ?
`

func (q *Queries) GetCommoditiesByBidId(ctx context.Context, bidid string) (string, error) {
	row := q.db.QueryRowContext(ctx, getCommoditiesByBidId, bidid)
	var commodityid string
	err := row.Scan(&commodityid)
	return commodityid, err
}

const getCommoditiesByCategory = `-- name: GetCommoditiesByCategory :many
SELECT CommodityId, UserID, Name, Description, Price, Status, Category, CreatedAt, UpdatedAt FROM Commodities WHERE Category = ?
`

type GetCommoditiesByCategoryRow struct {
	Commodityid string
	Userid      string
	Name        string
	Description string
	Price       string
	Status      string
	Category    string
	Createdat   time.Time
	Updatedat   time.Time
}

func (q *Queries) GetCommoditiesByCategory(ctx context.Context, category string) ([]GetCommoditiesByCategoryRow, error) {
	rows, err := q.db.QueryContext(ctx, getCommoditiesByCategory, category)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCommoditiesByCategoryRow
	for rows.Next() {
		var i GetCommoditiesByCategoryRow
		if err := rows.Scan(
			&i.Commodityid,
			&i.Userid,
			&i.Name,
			&i.Description,
			&i.Price,
			&i.Status,
			&i.Category,
			&i.Createdat,
			&i.Updatedat,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCommodity = `-- name: GetCommodity :one
SELECT CommodityId, UserID, Name, Description, Price, Status, Category, CreatedAt, UpdatedAt FROM Commodities WHERE CommodityId = ?
`

type GetCommodityRow struct {
	Commodityid string
	Userid      string
	Name        string
	Description string
	Price       string
	Status      string
	Category    string
	Createdat   time.Time
	Updatedat   time.Time
}

func (q *Queries) GetCommodity(ctx context.Context, commodityid string) (GetCommodityRow, error) {
	row := q.db.QueryRowContext(ctx, getCommodity, commodityid)
	var i GetCommodityRow
	err := row.Scan(
		&i.Commodityid,
		&i.Userid,
		&i.Name,
		&i.Description,
		&i.Price,
		&i.Status,
		&i.Category,
		&i.Createdat,
		&i.Updatedat,
	)
	return i, err
}

const getOTP = `-- name: GetOTP :one
SELECT OTP, ExpiresAt FROM Verifications WHERE UserID = ?
`

type GetOTPRow struct {
	Otp       int32
	Expiresat time.Time
}

func (q *Queries) GetOTP(ctx context.Context, userid string) (GetOTPRow, error) {
	row := q.db.QueryRowContext(ctx, getOTP, userid)
	var i GetOTPRow
	err := row.Scan(&i.Otp, &i.Expiresat)
	return i, err
}

const getPasswordByEmail = `-- name: GetPasswordByEmail :one
SELECT Password FROM Users WHERE Email = ?
`

func (q *Queries) GetPasswordByEmail(ctx context.Context, email string) (string, error) {
	row := q.db.QueryRowContext(ctx, getPasswordByEmail, email)
	var password string
	err := row.Scan(&password)
	return password, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT UserID, Name, Email, Password, Type FROM Users WHERE Email = ?
`

type GetUserByEmailRow struct {
	Userid   string
	Name     string
	Email    string
	Password string
	Type     string
}

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (GetUserByEmailRow, error) {
	row := q.db.QueryRowContext(ctx, getUserByEmail, email)
	var i GetUserByEmailRow
	err := row.Scan(
		&i.Userid,
		&i.Name,
		&i.Email,
		&i.Password,
		&i.Type,
	)
	return i, err
}

const getUserIDByEmail = `-- name: GetUserIDByEmail :one
SELECT UserID FROM Users WHERE Email = ?
`

func (q *Queries) GetUserIDByEmail(ctx context.Context, email string) (string, error) {
	row := q.db.QueryRowContext(ctx, getUserIDByEmail, email)
	var userid string
	err := row.Scan(&userid)
	return userid, err
}

const updateCommodityStatus = `-- name: UpdateCommodityStatus :exec
UPDATE Commodities SET Status = ? WHERE CommodityId = ?
`

type UpdateCommodityStatusParams struct {
	Status      string
	Commodityid string
}

func (q *Queries) UpdateCommodityStatus(ctx context.Context, arg UpdateCommodityStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateCommodityStatus, arg.Status, arg.Commodityid)
	return err
}

const verifyAccount = `-- name: VerifyAccount :exec
UPDATE Users SET IsVerified = 1 WHERE UserID = ?
`

func (q *Queries) VerifyAccount(ctx context.Context, userid string) error {
	_, err := q.db.ExecContext(ctx, verifyAccount, userid)
	return err
}
